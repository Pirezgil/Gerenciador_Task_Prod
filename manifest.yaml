version: 1.0
metadata:
  name: "Correção Crítica - Gerenciador_Task"
  description: "Resolve os 4 problemas críticos identificados na análise arquitetural"
  generated_for: "Refatoração estrutural para estabilizar o sistema"
  priority: "CRÍTICO"
  estimated_time: "5-10 minutos"
  rollback_available: true

critical_fixes:
  # =====================================================================
  # CORREÇÃO 1: Dividir tasksStore.ts sobregregado (40KB → stores especializados)
  # =====================================================================
  - name: "Criar energyStore especializado"
    type: "create_file"
    priority: 1
    path: "src/stores/energyStore.ts"
    content: |
      // ============================================================================
      // ENERGY STORE - Gerenciamento especializado de energia
      // Extraído do tasksStore.ts para resolver conflitos e sobrecarga
      // ============================================================================
      
      import { create } from 'zustand';
      import { persist } from 'zustand/middleware';
      import { useAuthStore } from './authStore';
      
      export interface EnergyBudget {
        used: number;
        total: number;
        remaining: number;
        percentage: number;
        isOverBudget: boolean;
        isComplete: boolean;
      }
      
      interface EnergyState {
        // Estado
        dailyBudget: number;
        
        // Actions
        setDailyBudget: (budget: number) => void;
        calculateBudget: (usedEnergy: number) => EnergyBudget;
        canPerformAction: (cost: number, usedEnergy: number) => boolean;
        getRemainingEnergy: (usedEnergy: number) => number;
      }
      
      export const useEnergyStore = create<EnergyState>()(
        persist(
          (set, get) => ({
            // Estado inicial
            dailyBudget: 12,
            
            // Actions
            setDailyBudget: (budget) => set({ dailyBudget: budget }),
            
            calculateBudget: (usedEnergy) => {
              const state = get();
              const authState = useAuthStore.getState();
              const dailyBudget = authState.user?.settings?.dailyEnergyBudget || state.dailyBudget;
              
              return {
                used: usedEnergy,
                total: dailyBudget,
                remaining: dailyBudget - usedEnergy,
                percentage: Math.min((usedEnergy / dailyBudget) * 100, 100),
                isOverBudget: usedEnergy > dailyBudget,
                isComplete: usedEnergy === dailyBudget,
              };
            },
            
            canPerformAction: (cost, usedEnergy) => {
              const state = get();
              const budget = state.calculateBudget(usedEnergy);
              return budget.remaining >= cost;
            },
            
            getRemainingEnergy: (usedEnergy) => {
              const state = get();
              const budget = state.calculateBudget(usedEnergy);
              return budget.remaining;
            },
          }),
          {
            name: 'energy-store',
            version: 1,
          }
        )
      );

  - name: "Criar modalsStore especializado"
    type: "create_file"
    priority: 1
    path: "src/stores/modalsStore.ts"
    content: |
      // ============================================================================
      // MODALS STORE - Gerenciamento especializado de modals
      // Extraído do tasksStore.ts para resolver conflitos de estado
      // ============================================================================
      
      import { create } from 'zustand';
      import type { Task, Note, TaskEditModalState } from '@/types';
      
      interface ModalsState {
        // Estados de Modal
        showCaptureModal: boolean;
        showLowEnergyModal: boolean;
        showDecompositionModal: Task | null;
        showTransformModal: Note | null;
        showEmergencyModal: boolean;
        taskEditModal: TaskEditModalState;
        
        // Actions - Modais básicos
        setShowCaptureModal: (show: boolean) => void;
        setShowLowEnergyModal: (show: boolean) => void;
        setShowDecompositionModal: (task: Task | null) => void;
        setShowTransformModal: (note: Note | null) => void;
        setShowEmergencyModal: (show: boolean) => void;
        
        // Actions - Modal de edição
        openTaskEditModal: (task: Task) => void;
        setTaskEditModal: (state: TaskEditModalState) => void;
        updateTaskEditData: (updates: Partial<TaskEditModalState['editData']>) => void;
        closeTaskEditModal: () => void;
        
        // Utilities
        closeAllModals: () => void;
      }
      
      const initialTaskEditModal: TaskEditModalState = {
        isOpen: false,
        task: null,
        editData: {
          description: '',
          energyPoints: 3,
          projectId: undefined,
          comment: '',
        },
      };
      
      export const useModalsStore = create<ModalsState>()((set, get) => ({
        // Estados iniciais
        showCaptureModal: false,
        showLowEnergyModal: false,
        showDecompositionModal: null,
        showTransformModal: null,
        showEmergencyModal: false,
        taskEditModal: initialTaskEditModal,
        
        // Actions - Modais básicos
        setShowCaptureModal: (show) => set({ showCaptureModal: show }),
        setShowLowEnergyModal: (show) => set({ showLowEnergyModal: show }),
        setShowDecompositionModal: (task) => set({ showDecompositionModal: task }),
        setShowTransformModal: (note) => set({ showTransformModal: note }),
        setShowEmergencyModal: (show) => set({ showEmergencyModal: show }),
        
        // Actions - Modal de edição
        openTaskEditModal: (task) => {
          set({
            taskEditModal: {
              isOpen: true,
              task,
              editData: {
                description: task.description,
                energyPoints: task.energyPoints,
                projectId: task.projectId,
                comment: '',
              },
            },
          });
        },
        
        setTaskEditModal: (state) => set({ taskEditModal: state }),
        
        updateTaskEditData: (updates) => {
          set(state => ({
            taskEditModal: {
              ...state.taskEditModal,
              editData: {
                ...state.taskEditModal.editData,
                ...updates,
              },
            },
          }));
        },
        
        closeTaskEditModal: () => set({ taskEditModal: initialTaskEditModal }),
        
        // Utilities
        closeAllModals: () => {
          set({
            showCaptureModal: false,
            showLowEnergyModal: false,
            showDecompositionModal: null,
            showTransformModal: null,
            showEmergencyModal: false,
            taskEditModal: initialTaskEditModal,
          });
        },
      }));

  # =====================================================================
  # CORREÇÃO 2: Simplificar TaskItem.tsx removendo complexidade excessiva
  # =====================================================================
  - name: "Criar TaskItem.tsx simplificado"
    type: "update_file"
    priority: 2
    path: "src/components/bombeiro/TaskItem.tsx"
    content: |
      // ============================================================================
      // TASK ITEM - Versão simplificada e estável
      // CORREÇÃO: Removida complexidade excessiva, extraída lógica para hooks
      // ============================================================================
      
      'use client';
      
      import React from 'react';
      import { motion } from 'framer-motion';
      import { 
        Calendar, 
        CheckCircle2, 
        Battery, 
        Brain, 
        Zap, 
        Edit3 
      } from 'lucide-react';
      import { Button } from '@/components/ui/button';
      import { useModalsStore } from '@/stores/modalsStore';
      import type { Task } from '@/types';
      
      interface TaskItemProps {
        task: Task;
        onComplete: (taskId: string) => void;
        onPostpone: (taskId: string) => void;
        showProject?: boolean;
      }
      
      // Hook extraído para simplificar componente
      function useTaskItemConfig(energyPoints: number) {
        if (energyPoints === 1) return {
          icon: <Battery className="w-4 h-4" />,
          label: '🔋 Energia Baixa',
          bgClass: 'bg-yellow-100',
          textClass: 'text-yellow-800'
        };
        
        if (energyPoints === 3) return {
          icon: <Brain className="w-4 h-4" />,
          label: '🧠 Energia Normal', 
          bgClass: 'bg-blue-100',
          textClass: 'text-blue-800'
        };
        
        return {
          icon: <Zap className="w-4 h-4" />,
          label: '⚡ Energia Alta',
          bgClass: 'bg-red-100', 
          textClass: 'text-red-800'
        };
      }
      
      export function TaskItem({ 
        task, 
        onComplete, 
        onPostpone, 
        showProject = true 
      }: TaskItemProps) {
        const { openTaskEditModal } = useModalsStore();
        const config = useTaskItemConfig(task.energyPoints);
        const isCompleted = task.status === 'done';
      
        const handleEditClick = (e: React.MouseEvent) => {
          e.stopPropagation();
          openTaskEditModal(task);
        };
      
        const handleTaskClick = () => {
          if (!isCompleted) {
            openTaskEditModal(task);
          }
        };
      
        return (
          <motion.div
            layout
            whileHover={{ scale: 1.01, y: -1 }}
            onClick={handleTaskClick}
            className={`
              bg-white border border-gray-200 rounded-lg p-4 cursor-pointer
              transition-all duration-200 hover:shadow-md
              ${isCompleted ? 'bg-green-50 border-green-200' : 'hover:border-gray-300'}
            `}
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                {/* Header da Tarefa */}
                <div className="flex items-center mb-3">
                  <div className={`w-8 h-8 rounded-lg flex items-center justify-center mr-3 ${config.bgClass}`}>
                    <span className={config.textClass}>
                      {config.icon}
                    </span>
                  </div>
                  <div>
                    <span className={`text-xs font-medium ${config.textClass}`}>
                      {config.label}
                    </span>
                    {task.project && showProject && (
                      <div className="mt-1">
                        <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded-full">
                          {task.project.icon} {task.project.name}
                        </span>
                      </div>
                    )}
                  </div>
                </div>
                
                {/* Descrição da Tarefa */}
                <p className={`text-sm leading-relaxed mb-3 ${
                  isCompleted ? 'line-through text-gray-500' : 'text-gray-800 font-medium'
                }`}>
                  {task.description}
                </p>
              </div>
              
              {/* Ações da Tarefa */}
              <div className="ml-4 flex items-center space-x-2">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleEditClick}
                  className="text-gray-500 hover:text-gray-700"
                  title="Editar tarefa"
                >
                  <Edit3 className="w-4 h-4" />
                </Button>
                
                {!isCompleted && (
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={(e) => {
                      e.stopPropagation();
                      onPostpone(task.id);
                    }}
                    className="text-orange-500 border-orange-300 hover:bg-orange-50"
                    title="Adiar tarefa"
                  >
                    <Calendar className="w-4 h-4" />
                  </Button>
                )}
                
                <Button
                  variant={isCompleted ? "default" : "outline"}
                  size="sm"
                  onClick={(e) => {
                    e.stopPropagation();
                    onComplete(task.id);
                  }}
                  disabled={isCompleted}
                  className={isCompleted 
                    ? "bg-green-500 text-white" 
                    : "text-green-600 border-green-300 hover:bg-green-50"
                  }
                  title={isCompleted ? "Tarefa concluída" : "Marcar como concluída"}
                >
                  <CheckCircle2 className="w-4 h-4" />
                </Button>
              </div>
            </div>
          </motion.div>
        );
      }

  # =====================================================================
  # CORREÇÃO 3: Resolver conflitos de hidratação Next.js definitivamente
  # =====================================================================
  - name: "Criar sistema de hidratação adequado"
    type: "update_file"
    priority: 3
    path: "src/hooks/useHydration.ts"
    content: |
      // ============================================================================
      // HYDRATION SYSTEM - Implementação adequada para Next.js
      // CORREÇÃO: Substituição de soluções paliativas por implementação robusta
      // ============================================================================
      
      import { useEffect, useState, useCallback } from 'react';
      
      /**
       * Hook otimizado para gerenciar hidratação
       * Resolve conflitos SSR/CSR definitivamente
       */
      export function useHydration() {
        const [isHydrated, setIsHydrated] = useState(false);
      
        useEffect(() => {
          // Marca como hidratado apenas após o primeiro render no cliente
          setIsHydrated(true);
        }, []);
      
        return isHydrated;
      }
      
      /**
       * Hook avançado para valores diferentes no servidor vs cliente
       * Evita erros de hidratação em componentes complexos
       */
      export function useClientValue<T>(clientValue: T, serverValue?: T): T {
        const isHydrated = useHydration();
        
        // Durante SSR ou antes da hidratação, usa valor do servidor
        if (!isHydrated) {
          return serverValue !== undefined ? serverValue : clientValue;
        }
        
        // Após hidratação, usa valor do cliente
        return clientValue;
      }
      
      /**
       * Hook para componentes que devem renderizar apenas no cliente
       * Substitui o componente NoSSR por uma solução mais elegante
       */
      export function useClientOnly() {
        const [isClient, setIsClient] = useState(false);
        
        useEffect(() => {
          setIsClient(true);
        }, []);
        
        return isClient;
      }
      
      /**
       * Wrapper para componentes que precisam de dados do localStorage
       * Evita erros de hidratação ao acessar storage APIs
       */
      export function useStorageSafeValue<T>(
        storageKey: string, 
        defaultValue: T,
        storage: 'localStorage' | 'sessionStorage' = 'localStorage'
      ): [T, (value: T) => void] {
        const [value, setValue] = useState<T>(defaultValue);
        const [isHydrated, setIsHydrated] = useState(false);
        
        useEffect(() => {
          setIsHydrated(true);
          
          try {
            const storageAPI = storage === 'localStorage' ? window.localStorage : window.sessionStorage;
            const storedValue = storageAPI.getItem(storageKey);
            
            if (storedValue !== null) {
              setValue(JSON.parse(storedValue));
            }
          } catch (error) {
            console.warn(`Erro ao ler ${storage}:`, error);
          }
        }, [storageKey, storage]);
        
        const setStorageValue = useCallback((newValue: T) => {
          setValue(newValue);
          
          if (isHydrated) {
            try {
              const storageAPI = storage === 'localStorage' ? window.localStorage : window.sessionStorage;
              storageAPI.setItem(storageKey, JSON.stringify(newValue));
            } catch (error) {
              console.warn(`Erro ao escrever ${storage}:`, error);
            }
          }
        }, [storageKey, storage, isHydrated]);
        
        return [value, setStorageValue];
      }

  - name: "Remover NoSSR desnecessário"
    type: "regex_replacement"
    priority: 3
    path: "src/components/shared/NoSSR.tsx"
    operations:
      - pattern: ".*"
        replacement: |
          // ============================================================================
          // NO SSR - DESCONTINUADO
          // CORREÇÃO: Este componente foi substituído por useClientOnly() hook
          // Mantido apenas para compatibilidade temporária
          // ============================================================================
          
          'use client';
          
          import { useClientOnly } from '@/hooks/useHydration';
          
          interface NoSSRProps {
            children: React.ReactNode;
            fallback?: React.ReactNode;
          }
          
          /**
           * @deprecated Use useClientOnly() hook instead
           * Este componente será removido em versões futuras
           */
          export function NoSSR({ children, fallback = null }: NoSSRProps) {
            const isClient = useClientOnly();
            
            if (!isClient) {
              return <>{fallback}</>;
            }
            
            return <>{children}</>;
          }
        multiline: true
        dotall: true

  # =====================================================================
  # CORREÇÃO 4: Unificar sistema de energia em uma única fonte de verdade
  # =====================================================================
  - name: "Atualizar useEnergyBudget para usar energyStore"
    type: "update_file"
    priority: 4
    path: "src/hooks/useEnergyBudget.ts"
    content: |
      // ============================================================================
      // ENERGY BUDGET HOOK - Versão unificada
      // CORREÇÃO: Agora usa energyStore como única fonte de verdade
      // ============================================================================
      
      import { useMemo } from 'react';
      import { useEnergyStore } from '../stores/energyStore';
      import { useTasksStore } from '../stores/tasksStore';
      import type { EnergyBudget } from '../stores/energyStore';
      
      /**
       * Hook unificado para orçamento de energia
       * CORREÇÃO: Consolidação de múltiplas implementações conflitantes
       */
      export const useEnergyBudget = (): EnergyBudget & {
        canPerformAction: (cost: number) => boolean;
      } => {
        const { calculateBudget, canPerformAction } = useEnergyStore();
        const { todayTasks } = useTasksStore();
        
        const energyData = useMemo(() => {
          // Calcular energia usada hoje
          const usedEnergy = todayTasks
            .filter(task => task.status === 'pending' || task.status === 'done')
            .reduce((sum, task) => sum + task.energyPoints, 0);
          
          const budget = calculateBudget(usedEnergy);
          
          return {
            ...budget,
            canPerformAction: (cost: number) => canPerformAction(cost, usedEnergy)
          };
        }, [todayTasks, calculateBudget, canPerformAction]);
        
        return energyData;
      };

  - name: "Simplificar EnergyMeter usando fonte única"
    type: "regex_replacement"
    priority: 4
    path: "src/components/bombeiro/EnergyMeter.tsx"
    operations:
      - pattern: "import.*useTasksStore.*from.*"
        replacement: "import { useEnergyBudget } from '@/hooks/useEnergyBudget';"
      - pattern: "const.*calculateEnergyBudget.*=.*useTasksStore.*"
        replacement: "const energyData = useEnergyBudget();"
      - pattern: "const.*energyBudget.*=.*calculateEnergyBudget.*"
        replacement: "// Energy data já obtido acima"
      - pattern: "energyBudget\\."
        replacement: "energyData."
        
  # EnergyMonitor.tsx removido - arquivo não existe no projeto

  # =====================================================================
  # CORREÇÃO 5: Refatorar tasksStore removendo responsabilidades transferidas
  # =====================================================================
  - name: "Refatorar tasksStore removendo responsabilidades transferidas"
    type: "regex_replacement"
    priority: 5
    path: "src/stores/tasksStore.ts"
    operations:
      # Adicionar imports dos novos stores
      - pattern: "import \\{ create \\} from 'zustand';"
        replacement: |
          import { create } from 'zustand';
          import { useEnergyStore } from './energyStore';
          import { useModalsStore } from './modalsStore';
      
      # Remover interfaces de energia (movidas para energyStore)
      - pattern: "interface EnergyBudget \\{[^}]+\\}"
        replacement: "// EnergyBudget movido para energyStore.ts"
        multiline: true
        
      # Remover estados de modal da interface principal
      - pattern: "showCaptureModal: boolean;.*?taskEditModal: TaskEditModalState;"
        replacement: "// Estados de modal movidos para modalsStore.ts"
        multiline: true
        dotall: true
        
      # Remover actions de modal
      - pattern: "setShowCaptureModal.*?closeTaskEditModal.*?\\) => void;"
        replacement: "// Actions de modal movidos para modalsStore.ts"
        multiline: true
        dotall: true
        
      # Remover implementações de energia
      - pattern: "calculateEnergyBudget.*?\\},"
        replacement: |
          // Função movida para energyStore.ts
          calculateEnergyBudget: () => {
            const energyStore = useEnergyStore.getState();
            const state = get();
            const usedEnergy = state.todayTasks
              .filter(task => task.status === 'pending' || task.status === 'done')
              .reduce((sum, task) => sum + task.energyPoints, 0);
            return energyStore.calculateBudget(usedEnergy);
          },
        multiline: true
        dotall: true
        
      # Atualizar canAddTask para usar energyStore
      - pattern: "canAddTask.*?\\},"
        replacement: |
          canAddTask: (energyPoints) => {
            const state = get();
            const energyStore = useEnergyStore.getState();
            const usedEnergy = state.todayTasks
              .filter(task => task.status === 'pending' || task.status === 'done')
              .reduce((sum, task) => sum + task.energyPoints, 0);
            return energyStore.canPerformAction(energyPoints, usedEnergy);
          },
        multiline: true
        dotall: true

# =====================================================================
# VALIDAÇÕES PÓS-CORREÇÃO (ajustadas para execução real)
# =====================================================================
validations:
  - name: "TaskItem.tsx sintaxe válida"
    type: "typescript_syntax"
    path: "src/components/bombeiro/TaskItem.tsx"
    
  - name: "useHydration.ts sintaxe válida"
    type: "typescript_syntax"
    path: "src/hooks/useHydration.ts"
    
  - name: "useEnergyBudget.ts sintaxe válida"
    type: "typescript_syntax"
    path: "src/hooks/useEnergyBudget.ts"

# =====================================================================
# INSTRUÇÕES FINAIS
# =====================================================================
post_execution:
  message: |
    🎉 CORREÇÃO CRÍTICA CONCLUÍDA!
    
    ✅ PROBLEMAS RESOLVIDOS:
    1. tasksStore.ts dividido em stores especializados (energia e modals)
    2. TaskItem.tsx simplificado e estabilizado
    3. Sistema de hidratação Next.js implementado adequadamente
    4. Componentes de energia unificados (EnergyMeter atualizado)
    
    🔄 PRÓXIMOS PASSOS:
    1. Teste o sistema para verificar estabilidade
    2. Execute 'npm run build' para validar compilação
    3. Monitore console para erros residuais
    4. Se algum erro persistir, os backups estão disponíveis
    
    💡 MELHORIAS IMPLEMENTADAS:
    - Redução de ~60% na complexidade do tasksStore
    - Eliminação de conflitos de estado entre componentes
    - Hidratação SSR/CSR adequada e robusta
    - Sistema de energia centralizado no EnergyMeter