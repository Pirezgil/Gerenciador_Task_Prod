'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Plus, Calendar, CheckCircle, Clock, Zap, Target, Trophy, Flame } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { NewProjectModal } from '@/components/shared/NewProjectModal';
import { useTasksStore } from '@/stores/tasksStore';
import { EnergyMeter } from './EnergyMeter';
import { TaskItem } from './TaskItem';
import { PostponedTasksRoom } from './PostponedTasksRoom';    
import WeeklyStats from './WeeklyStats';
import { TaskEditModal } from '@/components/shared/TaskEditModal';
import { UltraRewardingCelebration } from './UltraRewardingCelebration';

export function BombeiroPage() {
  // ✅ CORREÇÃO: Estado de hidratação para evitar SSR mismatch
  const [isHydrated, setIsHydrated] = useState(false);
  
  const {
    tasks,
    addTask,
    toggleTask,
    updateTask,
    deleteTask,
    getTasksByStatus,
    getCompletedTasksToday,
    getCompletedTasksThisWeek
  } = useTasksStore();

  const [showNewTaskModal, setShowNewTaskModal] = useState(false);
  const [editingTask, setEditingTask] = useState<any>(null);
  const [showCelebration, setShowCelebration] = useState(false);
  const [lastCompletedCount, setLastCompletedCount] = useState(0);

  // ✅ CORREÇÃO: Aguardar hidratação completa
  useEffect(() => {
    setIsHydrated(true);
  }, []);

  // ✅ CORREÇÃO FINAL: Simplificar useMemo e remover dependências problemáticas
  const pendingTasks = useMemo(() => {
    if (!isHydrated || !tasks) return [];
    try {
      return tasks.filter(task => task.status === 'pending');
    } catch (error) {
      console.warn('Erro ao filtrar tarefas pendentes:', error);
      return [];
    }
  }, [isHydrated, tasks]);
  
  const completedTasks = useMemo(() => {
    if (!isHydrated || !tasks) return [];
    try {
      return tasks.filter(task => task.status === 'completed');
    } catch (error) {
      console.warn('Erro ao filtrar tarefas completas:', error);
      return [];
    }
  }, [isHydrated, tasks]);
  
  const completedToday = useMemo(() => {
    if (!isHydrated || !tasks) return [];
    try {
      const today = new Date().toDateString();
      return tasks.filter(task => 
        task.status === 'completed' && 
        task.completedAt && 
        new Date(task.completedAt).toDateString() === today
      );
    } catch (error) {
      console.warn('Erro ao filtrar tarefas de hoje:', error);
      return [];
    }
  }, [isHydrated, tasks]);
  
  const completedThisWeek = useMemo(() => {
    if (!isHydrated || !tasks) return [];
    try {
      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
      
      return tasks.filter(task => 
        task.status === 'completed' && 
        task.completedAt && 
        new Date(task.completedAt) >= oneWeekAgo
      );
    } catch (error) {
      console.warn('Erro ao filtrar tarefas da semana:', error);
      return [];
    }
  }, [isHydrated, tasks]);

  // ✅ CORREÇÃO: Usar useCallback para estabilizar as funções
  const handleTaskComplete = useCallback(async (taskId: string) => {
    try {
      await toggleTask(taskId);
    } catch (error) {
      console.error('Erro ao completar tarefa:', error);
    }
  }, [toggleTask]);

  const handleEditTask = useCallback((task: any) => {
    setEditingTask(task);
  }, []);

  const handleUpdateTask = useCallback((taskId: string, updates: any) => {
    try {
      updateTask(taskId, updates);
      setEditingTask(null);
    } catch (error) {
      console.error('Erro ao atualizar tarefa:', error);
    }
  }, [updateTask]);

  const handleDeleteTask = useCallback((taskId: string) => {
    try {
      deleteTask(taskId);
      setEditingTask(null);
    } catch (error) {
      console.error('Erro ao deletar tarefa:', error);
    }
  }, [deleteTask]);

  // ✅ CORREÇÃO: Monitorar conclusão de tarefas para celebração
  useEffect(() => {
    if (!isHydrated) return;
    
    const currentCompletedCount = completedToday.length;
    
    // Só disparar celebração se realmente aumentou e não é o primeiro render
    if (currentCompletedCount > lastCompletedCount && lastCompletedCount > 0) {
      setShowCelebration(true);
      const timer = setTimeout(() => setShowCelebration(false), 3000);
      return () => clearTimeout(timer); // Cleanup do timer
    }
    
    setLastCompletedCount(currentCompletedCount);
  }, [isHydrated, completedToday.length, lastCompletedCount]);

  // ✅ CORREÇÃO: Loading state durante hidratação
  if (!isHydrated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-orange-50 to-red-50 dark:from-gray-900 dark:to-red-950">
        <div className="flex items-center justify-center min-h-screen">
          <div className="text-center">
            <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-orange-500 mx-auto mb-4"></div>
            <p className="text-lg font-semibold text-gray-700 dark:text-gray-300">
              Carregando Painel do Bombeiro...
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-orange-50 to-red-50 dark:from-gray-900 dark:to-red-950">
      {/* Header Section */}
      <div className="bg-white dark:bg-gray-800 shadow-sm border-b border-orange-200 dark:border-red-800">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <div className="p-3 bg-gradient-to-r from-orange-500 to-red-500 rounded-xl shadow-lg">
                <Flame className="w-8 h-8 text-white" />
              </div>
              <div>
                <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
                  🚒 Painel do Bombeiro
                </h1>
                <p className="text-gray-600 dark:text-gray-300 mt-1">
                  Extintor de tarefas atrasadas • Resgate de produtividade
                </p>
              </div>
            </div>
            
            <Button
              onClick={() => setShowNewTaskModal(true)}
              className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white shadow-lg"
            >
              <Plus className="w-5 h-5 mr-2" />
              Nova Emergência
            </Button>
          </div>
        </div>
      </div>

      {/* Stats Overview */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-orange-200 dark:border-red-800">
            <div className="flex items-center">
              <Clock className="w-8 h-8 text-orange-500" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Pendentes</p>
                <p className="text-2xl font-bold text-orange-600 dark:text-orange-400" suppressHydrationWarning>
                  {pendingTasks.length}
                </p>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-green-200 dark:border-green-800">
            <div className="flex items-center">
              <CheckCircle className="w-8 h-8 text-green-500" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Hoje</p>
                <p className="text-2xl font-bold text-green-600 dark:text-green-400" suppressHydrationWarning>
                  {completedToday.length}
                </p>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-blue-200 dark:border-blue-800">
            <div className="flex items-center">
              <Trophy className="w-8 h-8 text-blue-500" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Esta Semana</p>
                <p className="text-2xl font-bold text-blue-600 dark:text-blue-400" suppressHydrationWarning>
                  {completedThisWeek.length}
                </p>
              </div>
            </div>
          </div>

          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow-sm border border-purple-200 dark:border-purple-800">
            <div className="flex items-center">
              <Target className="w-8 h-8 text-purple-500" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total</p>
                <p className="text-2xl font-bold text-purple-600 dark:text-purple-400" suppressHydrationWarning>
                  {tasks?.length || 0}
                </p>
              </div>
            </div>
          </div>
        </div>

        <div className="space-y-6">
          {/* Energy Meter */}
          <EnergyMeter />

          {/* Weekly Stats */}
          <WeeklyStats />

          {/* Pending Tasks */}
          {pendingTasks.length > 0 && (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-orange-200 dark:border-red-800">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-xl font-semibold text-gray-900 dark:text-white flex items-center">
                  <Flame className="w-5 h-5 text-orange-500 mr-2" />
                  <span suppressHydrationWarning>Emergências Ativas ({pendingTasks.length})</span>
                </h2>
              </div>
              <div className="p-6 space-y-4">
                {pendingTasks.map((task) => (
                  <TaskItem
                    key={task.id}
                    task={task}
                    onToggle={handleTaskComplete}
                    onEdit={handleEditTask}
                  />
                ))}
              </div>
            </div>
          )}

          {/* Completed Tasks */}
          {completedTasks.length > 0 && (
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-green-200 dark:border-green-800">
              <div className="p-6 border-b border-gray-200 dark:border-gray-700">
                <h2 className="text-xl font-semibold text-gray-900 dark:text-white flex items-center">
                  <CheckCircle className="w-5 h-5 text-green-500 mr-2" />
                  <span suppressHydrationWarning>Incêndios Controlados ({completedTasks.length})</span>
                </h2>
              </div>
              <div className="p-6 space-y-4">
                {completedTasks.slice(0, 5).map((task) => (
                  <TaskItem
                    key={task.id}
                    task={task}
                    onToggle={handleTaskComplete}
                    onEdit={handleEditTask}
                  />
                ))}
              </div>
            </div>
          )}

          {/* Postponed Tasks Room */}
          <PostponedTasksRoom />
        </div>
      </div>

      {/* Modals */}
      <NewProjectModal
        isOpen={showNewTaskModal}
        onClose={() => setShowNewTaskModal(false)}
        onSubmit={(task) => {
          addTask(task);
          setShowNewTaskModal(false);
        }}
      />

      {editingTask && (
        <TaskEditModal
          isOpen={true}
          task={editingTask}
          onClose={() => setEditingTask(null)}
          onUpdate={handleUpdateTask}
          onDelete={handleDeleteTask}
        />
      )}

      {/* Celebration */}
      <AnimatePresence>
        {showCelebration && (
          <UltraRewardingCelebration
            isVisible={showCelebration}
            onClose={() => setShowCelebration(false)}
          />
        )}
      </AnimatePresence>
    </div>
  );
}

export default BombeiroPage;
